class ClientSession{
    private:
        SOCKET socket;
        char* buff;
    public:
        ClientSession(SOCKET, char*);
        ~ClientSession();
        recvFromClient();
        sendToClient();
}

class TcpServer{
    private:
        SOCKET main_socket;
        sockaddr_in server_addr;
    public:
        TcpServer(SOCKET, sockaddr_in);
        ~TcpServer();
}

class HttpServer{

}

class Middleware{
    Err err;
    Request req;
    Response res;
    Next next;

    void handler(Request req, Response res, std::function<void(Request, Response)> callback){
        callback(req, res);
        return 
    }

    void handler(Request req, Response res, Next next, std::function<void(Request, Response, Next)> callback){
        callback(req, res);
        return 
    }

    void handler(Request req, Response res, Next next, std::function<void(Request, Response, Next)> callback){
        callback(req, res);
        return 
    }
}

/**********************************************************************/

API: app.listen(port, handler()):- start a thread initializing a TcpServer object with port.
     app.use(handler(req:Request, res:Response, next:Next)):- add the param handler to the main middleware stack

App::listen(int port)

class App{
    public:
    middleware* pipeline;
    TcpServer server;
    HttpServer http;

    App();
    ~App();
    void listen(int port, function<void(string)> callback);
    App use(function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class
    App use(string method, string path, function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class
}