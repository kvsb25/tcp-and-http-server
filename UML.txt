/**************************************TCP_LAYER**************************************/

class ClientSession{
    private:
        SOCKET socket;
    public:
        char* buff;
    public:
        ClientSession(SOCKET, char*);
        ~ClientSession();
        recvFromClient();
        sendToClient();
}

class TcpServer{
    private:
        SOCKET main_socket;
        sockaddr_in server_addr;
    public:
        TcpServer(SOCKET&, sockaddr_in&); // bind and listen
        ~TcpServer();
        void start()// main loop
}

/**************************************HTTP_LAYER**************************************/

namespace http{

    extern unordered_map<int, string> status_messages; //predefined map for status codes and their associated messages

    struct Request{
        string method;
        string path;
        unordered_map<string, string> pathParams;
        unordered_map<string, string> queryParams;
        string version;
        unordered_map<string, string> headers;
        string body;
    }

    struct Response{

        int status_code;
        string status_message;
        unordered_map<string, string> headers;
        string body;
        
        Response(){
            // set default response, hence initialize the attributes of response body
        }

        Response& status(int s){
            this.status_code = s;
            this.status_message = status_messages[s];
            return *this;
        }

        Response& header(string k, string val){
            this.headers[k] = val;
            return *this;
        }

        Response& send(string data){
            this.body = data;
            return *this;
        }
    }

    class Server{

        Request& parseRequest(string rawRequest);
        string constructResponse(Response& response);
    }
}

/**********************************MIDDLEWARE_AND_PIPELINE********************************/

enum class MiddlewareType {
    DEFAULT,
    PATH,
    ERR
}

enum class HttpMethod{
    GET,
    POST,
    ...
};

class Middleware {
    public:
    MiddlewareType type;

    protected:
    Middleware(MiddlewareType t) : type(t) {}
}

class DefaultMiddleware : public Middleware{
    function<void(Request&, Response&, Next&)> handler;

    DefaultMiddleware(function<void(Request&, Response&, Next&)> callback) : Middleware(MiddlewareType::DEFAULT), handler(callback) {}
}

class PathMiddleware : public Middleware{
    HttpMethod method;
    string path;
    function <void(Request&, Response&)> handler;

    PathMiddleware(HttpMethod m, string p, function<void(Request&, Response&)> callback) : Middleware(MiddlewareType::PATH), method(m), path(p), handler(callback) {}
};

class ErrorMiddleware : public Middleware{
    function <void(Error&, Request&, Response&, Next)> handler;

    ErrorMiddleware(function <void(Error&, Request&, Response&, Next)> callback) : Middleware(MiddlewareType::ERR), handler(callback);
}

/*********************************APPLICATION_INTERFACE*************************************/

API: app.listen(port, handler()):- start a thread initializing a TcpServer object with port.
     app.use(handler(req:Request, res:Response, next:Next)):- add the param handler to the main middleware stack

App::listen(int port)

class App{
    public:
    vector<Middleware*> pipe;
    TcpServer server;

    App();
    ~App();
    void listen(int port, function<void(string)> callback = NULL);
    App& use(function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class
    App& use(string method, string path, function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class

    http::Response& handle(https::Request& req, https::Response& res){}
}

NOTE: while passing lambda functions to app.use() make sure that db instances or anything else that needs to be carried with the function in the memory
shall be mentioned in the closures


100 Continue
200 OK
201 Created
301 Moved Permanently
302 Found
400 Bad Request
401 Unauthorized
403 Forbidden
404 Not Found
405 Method Not Allowed
500 Internal Server Error
503 Service Unavailable

MAIN LOOP:
while(true){
    
    client_socket = accept(main_socket);
    
    clientSession cs(client_socket);
    string data = cs.recvFromClient(); // remove retry logic or add logic to exit thread on TTL exceed
    
    http::Request* req = &http.parse(data);
    http::Response* res = new http::Response();
    App::handle(req, res);
    string response_string = http.constructResponse(res);

    cs.sendToClient(response_string);
    cs.closeSession();
}