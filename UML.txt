/**************************************TCP_LAYER**************************************/

class ClientSession{
    private:
        SOCKET socket;
    public:
        char* buff;
    public:
        ClientSession(SOCKET, char*);
        ~ClientSession();
        recvFromClient();
        sendToClient();
}

class TcpServer{
    private:
        SOCKET main_socket;
        sockaddr_in server_addr;
    public:
        TcpServer(SOCKET&, sockaddr_in&); // bind and listen
        ~TcpServer();
        void start(vector<Middleware*>& stack); // main loop
}

/**************************************HTTP_LAYER**************************************/
namespace http{
    struct Request{

    }

    struct Response{

        Response(){
            // set default response, hence initialize the attributes of response body
        }
    }

    class Server{

        Request& parseRequest(string rawRequest);
        string constructResponse(Response& response);
    }
}
/**************************************SERVICE_LAYER**************************************/

class Service{
    vector<Middleware*> stack;
    function<void(http::Err)> next;

    Service(vector<Middleware*>& s) : stack(s); //constructor
    
    // all the opertations on the stack lie in this class
}

/**********************************MIDDLEWARE_AND_PIPELINE********************************/

enum class MiddlewareType {
    DEFAULT,
    PATH,
    ERR
}

enum class HttpMethod{
    GET,
    POST
};

class Middleware {
    public:
    MiddlewareType type;

    protected:
    Middleware(MiddlewareType t) : type(t) {}
}

class DefaultMiddleware : public Middleware{
    function<void(Request&, Response&, Next&)> handler;

    DefaultMiddleware(function<void(Request&, Response&, Next&)> callback) : Middleware(MiddlewareType::DEFAULT), handler(callback) {}
}

class PathMiddleware : public Middleware{
    HttpMethod method;
    string path;
    function <void(Request&, Response&)> handler;

    PathMiddleware(HttpMethod m, string p, function<void(Request&, Response&)> callback) : Middleware(MiddlewareType::PATH), method(m), path(p), handler(callback) {}
};

class ErrorMiddleware : public Middleware{
    function <void(Error&, Request&, Response&, Next)> handler;

    ErrorMiddleware(function <void(Error&, Request&, Response&, Next)> callback) : Middleware(MiddlewareType::ERR), handler(callback);
}

/*********************************APPLICATION_INTERFACE*************************************/

API: app.listen(port, handler()):- start a thread initializing a TcpServer object with port.
     app.use(handler(req:Request, res:Response, next:Next)):- add the param handler to the main middleware stack

App::listen(int port)

class App{
    public:
    vector<Middleware*> pipe;
    TcpServer server;

    App();
    ~App();
    void listen(int port, function<void(string)> callback = NULL);
    App use(function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class
    App use(string method, string path, function<void(Request, Response)> callback); // use method chaining here and overloading for each type of callback as in middleware class
}